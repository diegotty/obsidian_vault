---
related to: "[[01 - introduction to computer security]]"
created: 2025-03-02T17:41
updated: 2025-10-13T11:47
completed: false
---
# symmetric encryption
symmetric encryption is the universal technique for providing confidentiality for transmitted or stored data. it is also referred as *conventional encryption* or *single-key encryption*. two requirements need to be met for secure use:
- a strong encryption algorithm
- sender and receiver must have obtained copies of the secret key in a secure fashion, and must keep the key *secure*
>[!info] simplified model of symmetric encryption
![[Pasted image 20251013091327.png]]

## symmetric encryption attacks
2 types of attacks are used:
- **cryptanalitic attacks**: these attacks rely on the nature of the algorithm,  the knowledge of the general characteristics of the plaintext, or some sample plaintext-ciphertext pairs. this knowledge is then used to attempt to deduce the key used to encrypt plaintexts
- **brute-force attacks**: try all possible keys on some ciphertext, until an intelligible translation into plaintext is obtained
	- on average, half of all possible keys must be tried to achieve success
## types of ciphers
- **block ciphers**: they process the input of one block of elements at a time. they produce an output block for each input block. they are more common and can reuse keys
- **stream ciphers**: they process the input elements continuously, producing output one element at a time. they are faster and use far less code than block ciphers, and encrypt plaintext one *byte at a time*.
>[!info] block vs stream ciphers
![[Pasted image 20251013094151.png]]
>- a pseudorandom stream is one that is unpredictable, without the knowledge of the input key
## symmetric encryption algorithms
the most known are:
- **DES** (DEA / data encryption standard): block cipher that uses 64bit plaintext blocks and 56bit key to produce a 64bit cipher block.
	- now considered inscure
	- **3DES**: repeats DES 3times, with 2 or 3 unique keys
- **AES** (advanced encryption standard / **rijndael**): 128bit block cipher, with 128,192 or 256bit secret keys
	- made as a replacement to 3DES
	- the most popular and widely used symetric encryption algorithm in the modern IT industry
  **RC4** (ARC4): stream cipher with 40-2048bit secret keys
	- now also considered insecure
  >[!info] brute forcing modern block ciphers
  ![[Pasted image 20251013092911.png]]

symmetric encryption is usually applied to a unit of dat larger than a single 64bit or 128bit block, and the simplest way to approach multiple-block encryption is **ECB** (electronic codebook), where each block of plaintext is encrypted using the same key. this leaves exploits available in case of regularities in the plaintext.
- there are modes of operation to overcome this
## message authentication
message autentication, protects against active attacks and verifies that the received message is authentic: contents have not been altered, the source is authentic and the message is received timely and in correct sequence
- it can be implemented with conventional encryption

message encryption by itself does not guarantee authentication. however we can combine authentication and confidentiality in a single algorithm, by using *encryption + authentication tag*
- however, typically message auth is separate from message encryption, and message authentication can be needed without the need for confidentiality (ex: applications in which the same message is broadcasted to a number of destinations)
the following are different ways to ensure authentication:
### MAC
a *message authentication code* (the authentication tag) is used to verify the integrity and authenticity of the message. it could be generated by a number of algorithms, with the requirement that the authentication algorithm need not be reversible !
>[!info] message authentication code
![[Pasted image 20251013110304.png|400]]
note that the MAC takes a *secret key* as input !
### MAC with one-way hash functions
a **cryptographic hash function** is used to produce a “fingerprint” of a file/message/block of data: it generates a set of $k$ bits from a set of $L (≥k)$ bits. the result of the function is called *hash value*, *digest* or *checksum*
>[!info] mac + hash function
![[Pasted image 20251013110607.png|400]]
>- (*a*): the digest is encrypted with a secret key
>- (*b*): the digest is encrypted with the sender’s private key (we use public-key encryption). as an advantage, this implementation does not require the distribution of secret keys, and provides a digital signature (it proves it came from a known sender, as it gets encrypted with its private key)
>- (*c*): a secret key (known to sender and receiver) is added at the start and the end of the message that gets sent to the hash function
>
>in all three instances, the receiver produces a new digest using the same hash function and if it matches with the hash received, then authentication is ensured !
>note that the hash function does not take a secret key as input, unlike the MAC
#### properties for hash functions
hash functions aimed at authentication need to meet these properties:
- can be applied to a block of data of any size
- produce a fixed-length output
- the result $H(x)$ is relatively easy to compute for any given $x$
- one-way, or pre-image resistant: given $h$, it is computationally infeasible to find $x \text{  t.c.} H(x)=h$ 
- computationally infeasible to find $y \neq x \text{ .t.c. } H(y)=H(x)$
- collision resistant or with strong collision resistance: computationally infeasible to find any pair $(x,y) \text{ t.c. }H(x)=H(y)$
#### attacking hash functions
2 approaches are used to attack hash functions:
- exploit logical weakness in the algorithm
- strength of hash function depends solely on the length of the hash code produced by the algorithm
**SHA** (secure hash algorithm) is the most widely used family of hash algorithms (ex: SHA-256, SHA-512)
# public-key encryption
the public-key encryption structure was publicly proposed by Diffie and Hellman in 1976, and it is based on mathematical functions.
it uses **asymmetric** encryption: 2 separate keys, a *public key* (made public for others to use) and a *private key* (private to the owner). files crypted with the public key, can only be decrypted using the private key, and viceversa.
- take notice that a protocol is needed for distribution of the keys !
- keys need to be huge (thousands of bits)
>[!info] encryption with public key
![[Pasted image 20251013112343.png]]
ensures *confidentiality* (only the receiver can decrypt the message)

>[!info] encryption with private key
![[Pasted image 20251013112437.png]]
ensures *authenticity*, and can be verified by anyone with the sender’s public key

depending on the encryption algorithm used (**RSA**, **DSS**, **ECC**, **Diffie-Hellman**, …), public-key cryptosystems (frameworks that implement public-key encryption) can have different uses. the main ones are:
- digital signature
- symmetric key distribution (public-private keys are too big to be used in file encryption)
- encryption of secret keys

such public-key cryptosystems must met the following requirements:
- computationally easy to create key pairs
- computationally easy for receiver knowing private key, to decrypt ciphertext
- computationally easy for sender knowing public key, to encrypt messages
- computationally infeasible for opponent to to otherwise recover original message
- computationally infeasible for opponent to determine private key from public key
- useful if either key can be used for each role
# digital signature
>[!def] definition (NIST)
a digital signature is the result of a cryptographic transformation of data that, when properly implemented, provides a mechanism for verifying origin *authentication*, *data integrity* and signatory *non-repudiation*

it is a data-dependent bit pattern, generated by an agent, as a function of a file/message/data block
>[!info] process
![[Pasted image 20251013113810.png]]

### digital envelope
it is a secure method for transmitting encrypted messages using both symmetric and asymmetric encryption !
>[!info] process
![[Pasted image 20251013114729.png]]

## random numbers
random numbers are used for the generation of:
- keys for public-key algorithms
- stream keys for symmetric stream ciphers
- symmetric keys for use as a temporary sessione key, or in creating a digital envelope
- handshaking to prevent replay attacks
- session keys
random numbers need to meet the following requirements:
- **uniform distribution**: frequency of occurence of each of the numbers should be approximately the same
- **independence**: no one value in the sequence can be inferred from the others
making it unpredictable to predict future elements on the basis of earlier elements (or math)
>[!info] random vs pseudorandom
cryptographic applications typically make use of algorithmic techniques for random number generation, but algorithms are **deterministic** and therefore produce sequences of numbers that are not **statistically** random (*pseudorandom*).
>
a **TRNG** (*true random number generator*) uses a nondeterministic source to produce randomness (radiation, gas discharge, leaky capacitors).
>- TRNG are increasingly provided on modern CPUs !

