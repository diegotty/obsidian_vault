---
related to: "[[01 - introduction to computer security]]"
created: 2025-03-02T17:41
updated: 2025-10-13T11:17
completed: false
---
# symmetric encryption
symmetric encryption is the universal technique for providing confidentiality for transmitted or stored data. it is also referred as *conventional encryption* or *single-key encryption*. two requirements need to be met for secure use:
- a strong encryption algorithm
- sender and receiver must have obtained copies of the secret key in a secure fashion, and must keep the key *secure*
>[!info] simplified model of symmetric encryption
![[Pasted image 20251013091327.png]]

## symmetric encryption attacks
2 types of attacks are used:
- **cryptanalitic attacks**: these attacks rely on the nature of the algorithm,  the knowledge of the general characteristics of the plaintext, or some sample plaintext-ciphertext pairs. this knowledge is then used to attempt to deduce the key used to encrypt plaintexts
- **brute-force attacks**: try all possible keys on some ciphertext, until an intelligible translation into plaintext is obtained
	- on average, half of all possible keys must be tried to achieve success
## types of ciphers
- **block ciphers**: they process the input of one block of elements at a time. they produce an output block for each input block. they are more common and can reuse keys
- **stream ciphers**: they process the input elements continuously, producing output one element at a time. they are faster and use far less code than block ciphers, and encrypt plaintext one *byte at a time*.
>[!info] block vs stream ciphers
![[Pasted image 20251013094151.png]]
>- a pseudorandom stream is one that is unpredictable, without the knowledge of the input key
## symmetric encryption algorithms
the most known are:
- **DES** (DEA / data encryption standard): block cipher that uses 64bit plaintext blocks and 56bit key to produce a 64bit cipher block.
	- now considered inscure
	- **3DES**: repeats DES 3times, with 2 or 3 unique keys
- **AES** (advanced encryption standard / **rijndael**): 128bit block cipher, with 128,192 or 256bit secret keys
	- made as a replacement to 3DES
	- the most popular and widely used symetric encryption algorithm in the modern IT industry
  **RC4** (ARC4): stream cipher with 40-2048bit secret keys
	- now also considered insecure
  >[!info] brute forcing modern block ciphers
  ![[Pasted image 20251013092911.png]]

symmetric encryption is usually applied to a unit of dat larger than a single 64bit or 128bit block, and the simplest way to approach multiple-block encryption is **ECB** (electronic codebook), where each block of plaintext is encrypted using the same key. this leaves exploits available in case of regularities in the plaintext.
- there are modes of operation to overcome this
## message authentication
message autentication, protects against active attacks and verifies that the received message is authentic: contents have not been altered, the source is authentic and the message is received timely and in correct sequence
- it can be implemented with conventional encryption

message encryption by itself does not guarantee authentication. however we can combine authentication and confidentiality in a single algorithm, by using *encryption + authentication tag*
- however, typically message auth is separate from message encryption, and message authentication can be needed without the need for confidentiality (ex: applications in which the same message is broadcasted to a number of destinations)
the following are different ways to ensure authentication:
### MAC
a *message authentication code* (the authentication tag) is used to verify the integrity and authenticity of the message. it could be generated by a number of algorithms, with the requirement that the authentication algorithm need not be reversible !
>[!info] message authentication code
![[Pasted image 20251013110304.png|400]]
note that the MAC takes a *secret key* as input !
### MAC with one-way hash functions
a **cryptographic hash function** is used to produce a “fingerprint” of a file/message/block of data: it generates a set of $k$ bits from a set of $L (≥k)$ bits. the result of the function is called *hash value*, *digest* or *checksum*
>[!info] mac + hash function
![[Pasted image 20251013110607.png|400]]
>- (*a*): the digest is encrypted with a secret key
>- (*b*): the digest is encrypted with the sender’s private key (we use public-key encryption). as an advantage, this implementation does not require the distribution of secret keys, and provides a digital signature (it proves it came from a known sender, as it gets encrypted with its private key)
>- (*c*): a secret key (known to sender and receiver) is added at the start and the end of the message that gets sent to the hash function
>
>in all three instances, the receiver produces a new digest using the same hash function and if it matches with the hash received, then authentication is ensured !
>note that the hash function does not take a secret key as input, unlike the MAC
#### properties for hash functions
hash functions aimed at authentication need to meet these properties:
- can be applied to a block of data of any size
- produce a fixed-length output
- the result $H(x)$ is relatively easy to compute for any given $x$
- one-way, or pre-image resistant: given $h$, it is computationally infeasible to find $x \text{  t.c.} H(x)=h$ 
- computationally infeasible to find $y \neq x \text{ .t.c. } H(y)=H(x)$
- collision resistant or with strong collision resistance: computationally infeasible to find any pair $(x,y) \text{ t.c. }H(x)=H(y)$
#### attacking has functions
2 approaches are used to attack hash functions:
- exploit logical weakness in the algorithm
- strength of hash function depends solely on the length of the hash code produced by the algorithm