---
created: "2024-10-22"
done ?: "- [ ]"
---
# scheduling tradizionale di UNIX
lo scheduling di UNIX combina priorità e round-robin
- il quanto di tempo dura 1s
- esistono quindi diverse code, per gestire la priorità, e all’interno di ciasuna si fa round-robin
- le priorità vengono ricalcolate ogni secondo, e più un processo resta in esecuzione, più viene spinto in coda a minore priorità (feedback)
le priorità iniziali sono basate sul tipo di processo:
0. swapper (alta) (gestisce la memoria virtuale)
1. controllo di un dispositivo I/O a blocchi
2. gestione di file
3. controllo di un dispositivo di I/O a caratteri (tastiera o monitor vecchi (?))
4. processi utente (bassa)
## formula di scheduling
$$CPU_{j}(i)= \frac{CPU_{j}(i-1)}{2}$$
$$P_{j}(i)=Base_{j}+ \frac{CPU_{j}(i)}{2} + nice_{j}$$
- $CPU_{j}$ è una misura di quanto il processo $j$ ha usato il processore nell’intervallo $i$, con exponential averaging dei tempi passati $(\alpha = \frac{1}{2})$
	- per i running, $CPU_{j}$ viene incrementato di 1 ogni $\frac{1}{60}$ di secondo
- $Base_{j}$ è la priorità iniziale del processo
- $nice_{j}$ può essere usato dal processo stesso per “autodeclassarsi” come avente bassa priorità (lo usa il sistema per declassare processi che sa essere di minore importanza)
>[!example]
![[Pasted image 20241022092933.png]]
durante ogni quanto: il CPU count del processo in esecuzione viene aumentato di 1 ogni sessantesimo di secondo
a fine quanto: vengono ricalcolate tutte le priorità ($P_{j}(i)$), usando i valori aggionrati di $CPU_{j}(i)$