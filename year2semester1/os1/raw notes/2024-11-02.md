---
created: "2024-11-02"
done ?: "- [ ]"
---
# elementi centrali per il progetto del SO
- fetch policy
- placement policy
- replacement policy
- gestione del resident set
- politica di pulitura
- controllo del carico
il tutto, cercando di minimizzare i page fault; non c’è una politica sempre vincente
## fetch policy
decide quando una pagina debba essere portata in RAM
si usano principalmente due politiche:
- paginazione su richiesta (demand paging): quando una pagina richiede una cella di memoria che sta in una pagina che non è caricata nella memoria principale, essa viene presa dal disco e caricata in RAM
	- usando questa politica, all’inizio del processo ci saranno molti page fault, in quanto in RAM sarà presente solo la prima pagina
- prepaginazione (prepaging): cerca di anticipare le necessità del processo, portano in RAM più pagine di quelle richieste (sfruttando località e la capacità dei dischi moderni (dischi ottimizzati per trasferimento di grandi blocchi))
## placement policy
decide dove mettere una pagina in memoria principale quando c’è almeno un frame libero ( se non ci sono frame liberi, si una la replacement policy !)
dato che c’è l’hardware per la traduzione degli indirizzi, una pagina può essere messa ovunque
- tipicamente; il primo frame libero (quello con l’indirizzo più basso, è quello dove viene messa la pagina)
## replacement policy
decide cosa fare se occorre portare una pagina in RAM, e tutti i frame sono già occupati
in questa situazione qualche pagina va sostituita, sovrascrivendo il rispettivo frame
per gesitre ciò esistono vari agoritmi (replacement policy), in quanto bisogna minimizzare la probabilià che la pagina appena sostituita venga richiesta di nuovo subito dopo
- quando viene swappata una pagina, bisogna aggiornare la sua PTE !! (in particolare, il bit M)
## gestione del resident set
racchiude due problemi:
- **gestione del resident set**: quanti frame di RAM da allocare per ogni processo da eseguire\in esecuzione ( ad alcuni processi potrebbero bastare un paio di frame, ad altri ne potrebbero service centinaia. ciò si gestisce in 2 modi:
	- allocazione fissa: numero di frame deciso al tempo di creazione di un processo
	- allocazione dinamica: numero di frame varia durante la vita del processo, magari basandosi sulle statistiche che a mano a mano vengono raccolte
- **gestione del replacement scope**: scelta, in fase di rimpiazzo di un frame, tra i frame che appartengono al processo corrente **oppure** anche tra i frame di un processo qualsiasi. ciò si gestisce in 2 modi:
	- politica locale: si sceglie solo tra gli altri frame dello stesso processo
	- politica globale: si può scegliere qualsiasi frame (basta che non sia del SO), ciò comporta un calcolo in più !

si nota come, pur avendo 4 politiche da poter combinare (a coppie di 2), si possono avere in tutto 3 possibili strategie, in quanto con l’allocazione fissa, la politica globale non è applicabile, altrimenti si potrebbe ampliare il resident set di un processo scegliendo un frame di un altro processo per il rimpiazzo (e quindi non sarebbe più allocazione fissa)
>[!figure] ![[Pasted image 20241102103108.png]]
>si nota come nel secondo grafico, lo “sweet spot” è W, non N (se carico tutte le pagine di un processo in RAM, la multiprogrammazione diminuisce drasticamente)
### frame locking
si può “bloccare” un frame, cioè, rendere impossibile il rimpiazzamento di esso: se un frame è locked, non si può sostituire !
questa caratteristica è usata a livello di kernel del SO, e si gestisce con un bit ( gestito a livello hardware)
## politica di pulitura
come nella cache, può capitare che una pagina caricata in RAM venga modificata(sempre in RAM). la politica di pulitura gestisce quando riportare la modifica al disco (se riportarla quando avviene la modifica, o quando la pagina viene sostituito )
- si fa tipicamente una via di mezzo (intrecciata con il page buffering), cioè si raccolgono un po’ di richieste di frame da modificare e li si esegue
# medium term scheduler
torniamo al [[intro allo scheduling#medium-term scheduling]], con più informazioni riguardo al suo lavoro !
>[!figure] ![[Pasted image 20241102105949.png]]
>si nota come dopo il picco del grafico, l’utilizzo del processore decresce in quanto ci sono troppi page fault e si spende troppo tempo ad aspettare le risposte del disco (per il rimpiazzo)
## controllo del carico
significa cercare di tenere la multiprogrammazione alta, ma senza avere resident sets così bassi da avere troppi page fault
il carico viene controllato aumentando e diminuendo il numero di processi attivi, aumentando la multiprogrammazione ma senza arrivare al thrashing
- cambiando lo stato da `READY` a `READY/SUSPEND` oppure da `BLOCKED` a `BLOCKED/SUSPEND` e viceversa ! (inoltre si cerca di sospendere processi che non possono o in futuro non saranno ready, e di portare in RAM processi che potranno essere eseguiti (es: non stanno aspettando risposte di richieste I/O))
>[!info] un processo è suspended quando il suo resident set è 0

le **politiche di monitoraggio** 
periodicamente, un processo del SO controlla la situazione della multiprogrammazione, e decide se è necessario aumentare o diminuire i processi attivi