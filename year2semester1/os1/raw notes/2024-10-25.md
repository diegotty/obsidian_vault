---
created: "2024-10-25"
done ?: "- [ ]"
---
le partizioni sono decise all’inizio e non cambiano più come il parzionamento fisso variabile, ma le partizioni create sono a dimensione incrementale
- nella foto, si possono gestire fino a processi di 16M senza obbligare il programmatore a usare l’overlaying, e per i processi più piccoli ci sono le partizioni più piccole
dato che esisono partizioni di diversa lunghezza, bisogna usare un **algoritmo di posizionamento** che segue delle regole:
- il processo va nella partizione più piccola che può contenerlo, per minimizzare la quantità di spazio sprecato
ciò si può ottenere in 2 modi: con una coda per partizione, o una coda unica 
### problemi irrisolti
- c’è un numero massimo di processi in memoria principale, pari al numero di partizioni deciso inizialmente
- se ci sono molti processi piccoli, la memoria verrà usata in modo inefficiente (sia con partizionamento fisso che fisso variabile)
# partizionamento dinamico
le partizioni variano sia in misura che in quantità, e per ciascun processo viene allocata esattamente la quantità di memoria che serve
usando il partizionamento dinamico, si va in contro a:
- frammentazione esterna: la memoria non usata da nessuno dei processi viene frammentata (guarda esempio)
la frammentazione può essere risolta con la **compattazione**: il SO sposta i processi di modo che siano contigui
- ciò però ha un grande overhead
inoltre, come nel partizionamento fisso variabile, devo decidere dove mettere ogni processo. ne esistono diversi:
- **algoritmo best-fit**: sceglie il blocco la cui misura è più vicina a quella del processo da posizionare. in questo modo però, lascia dei frammenti molto piccoli, e costringe al SO di fare spesso la compattazione
- **algoritmo first-fit**: scorre la memoria dall’inizio, prende il primo blocco con abbastanza memoria. in questo modo  è molto veloce, ma tende a riempire solo la prima parte della memoria
- **algorimo next-fit**: come il first-fit, ma tiene conto dell’ultima posizione assegnata ad un processo, e partendo da lì la ricerca per una partizione libera.
>[!example] esempio dei tre algoritmi
![[Pasted image 20241025082900.png]]
# buddy system
permette un compromesso tra partizionamento fisso e variabile
sia $2^U$ la dimensione dello user space (memoria principale - spazio OS), ed $s$ la dipensione di un processo da mettere in RAM