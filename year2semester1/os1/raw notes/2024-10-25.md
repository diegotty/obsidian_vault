---
created: "2024-10-25"
done ?: "- [ ]"
---
le partizioni sono decise all’inizio e non cambiano più come il parzionamento fisso variabile, ma le partizioni create sono a dimensione incrementale
- nella foto, si possono gestire fino a processi di 16M senza obbligare il programmatore a usare l’overlaying, e per i processi più piccoli ci sono le partizioni più piccole
dato che esisono partizioni di diversa lunghezza, bisogna usare un **algoritmo di posizionamento** che segue delle regole:
- il processo va nella partizione più piccola che può contenerlo, per minimizzare la quantità di spazio sprecato
ciò si può ottenere in 2 modi: con una coda per partizione, o una coda unica 
### problemi irrisolti
- c’è un numero massimo di processi in memoria principale, pari al numero di partizioni deciso inizialmente
- se ci sono molti processi piccoli, la memoria verrà usata in modo inefficiente (sia con partizionamento fisso che fisso variabile)
# partizionamento dinamico
le partizioni variano sia in misura che in quantità, e per ciascun processo viene allocata esattamente la quantità di memoria che serve
usando il partizionamento dinamico, si va in contro a:
- frammentazione esterna: la memoria non usata da nessuno dei processi viene frammentata (guarda esempio)
la frammentazione può essere risolta con la **compattazione**: il SO sposta i processi di modo che siano contigui
- ciò però ha un grande overhead
inoltre, come nel partizionamento fisso variabile, devo decidere dove mettere ogni processo. ne esistono diversi:
- **algoritmo best-fit**: sceglie il blocco la cui misura è più vicina a quella del processo da posizionare. in questo modo però, lascia dei frammenti molto piccoli, e costringe al SO di fare spesso la compattazione
- **algoritmo first-fit**: scorre la memoria dall’inizio, prende il primo blocco con abbastanza memoria. in questo modo  è molto veloce, ma tende a riempire solo la prima parte della memoria
- **algorimo next-fit**: come il first-fit, ma tiene conto dell’ultima posizione assegnata ad un processo, e partendo da lì la ricerca per una partizione libera.
>[!example] esempio dei tre algoritmi
![[Pasted image 20241025082900.png]]
# buddy system
permette un compromesso tra partizionamento fisso e variabile(ed è ancora usato, in casi particolari !)
sia $2^U$ la dimensione dello user space (memoria principale - spazio OS), ed $s$ la dipensione di un processo da mettere in RAM
si prosegue in questo modo:
la memoria viene dimezzata fino a trovare una $X$ tale che $2^{X-1} < s \leq 2^X$, con $L \leq X \leq U$, in cui $L$ è usato per dare un lower bound (non creare partizioni troppo piccole)
una delle due porzioni dell’ultimo dimezzamento è usta per il processo
quando il processo finisce, se l’altra partizione creata dal dimezzamento è libera, **si può fare la fusione**
>[!example] esempio di buddy system
![[Pasted image 20241025092804.png]]

>[!figure] rappresentazione in albero binario del buddy system
![[Pasted image 20241025092932.png]]
data la natura del buddy system (il dimezzamento ricorsivo), è molto facile rappresentare gli spazi di memoria come un albero binario

# paginazione semplice
**sia la memoria che i processi** vengono partizionati in pezzi di grandezza uguale (e piccola)
- i pezzi di processi (in genere in memoria ausiliaria) sono chiamati **pagine**
- i pezzi di memoria sono chiamati **frame**
ogni pagina, per essere usata, deve essere collocata in un frame, e data la partizione in grandezza uguale, **ogni pagina può essere collocata in qualunque frame**
- pagine contigue possono essere messe in frame distanti
c’è un grande overhead giustificato dal miglioramento di prestazioni
i SO che adottano la paginazione mantengono una tabella delle pagine di ogni processo, che, per ogni pagina del processo, indica in che frame effettivo si trova
- la situazione dei module relativi va modificata: ogni indirizzo di memoria può essere visto come un numero di pagina e un offset al suo interno
quando c’è un process swit