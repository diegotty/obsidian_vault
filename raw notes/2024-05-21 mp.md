IntStream, DoubleStream e LongStream si ottengono da uno stream, con i metodi mapToInt, maToLong, e maToDouble
dispongono di 2 metodi statici:
- range(inizio, fine) intervallo esclusivo (aperto a destra)
- rangeClosed(inizio, fine) intervallo inclusivo (chiuso a destra)
```java
IntStream.range(0, 10).filter(n -> n % 2 == 1).forEach(System.out::println);
```


```java
List<String> s = Arrays.asList("a", "b", "c");
s.stream   //Stream<String>
.mapToInt(String::length)    //IntStream
.asLongStream()    //LongStream
.mapToDouble(x -> x / 42.0)    //DoubleStream
.boxed()   //Stream<Double>
.mapToLong( x -> 1L)    //LongStream
.mapToObj(x -> "");    //Stream<String>
```

.boxed() esiste solo in IntStream, DoubleStream e LongStream, e permette di ritornare a uno Stream di Integer/Double/Long

## ottenere uno Stream infinito
l’interfaccia Stream espone un metodo `iterate` che, partendo dal primo argomento, restituisce uno stream infinito ocn valori successivi applicando la funzione passata come secondo argomento
```java
Stream<Integer> numbers = Stream.iterate(0, n -> n +10);
//inoltre è possibile limitare uno stream infinito con il metodo limit
numbers.limit(5).forEach(System.out::println);
//esiste anche un secondo metodo iterate che prende come secondo argomento un predicato (la funzione diventa il terzo argomento). lo stream smette di dare valori (esce) quando il predicato del terzo argomento è false
Stream<Integer> numbers = Stream.iterate(0, n -> n < 50, n+10);
```

>[!tuff] practice what you preach, stay hard
I'm not crazy, I'm just not you
David Goggins

ci conviene sempre filtrare il prima possibile !!
le operazioni stateful non ci permettono di creare delle pipeline!! non ci permettono di parallelizzare operazioni indipendenti tra di loro
//slide 61. limit runs in parallelo !!
ci vuole comunque intuizione a scrivere il codice per ottimizzare l’esecuzione delle operazioni

## fare copie di stream
si può creare un builder di stream mediante una lambda 
```java
Supplier<Stream<String>> streamSupplier = () -> Stream.of("d2", "a2", "b1", "b3", "c");
// add esempio 62
```

## stream paralleli
`heap e metaspace sono condivisi tra i thread, di stack ce n’è uno solo`
- le operazioni su stream sequenziali sono effettuate in un singolo thread
- le operazioni su stream paralleli, invece, sono effettuate concorrentemente su thread multipli
nanoTime() ritorna i secondi dal 1 gennaio 1971