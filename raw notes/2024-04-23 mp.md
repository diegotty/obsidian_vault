# more interfacce funzionali built-in
### predicate 
funzione a valori booleani, a un solo argomento generico T
- si usa una lambda function 
```java
Predicate<String> predicate2 = s -> s.startsWith("f");
Predicate<Boolean> nonNull = Objects::nonNull;
```
si possono creare predicati composti con i metodi di predicate(or(), and(), negate() )
### function
funzione a un argomento di tipo T e un tipo di ritorno R entrambi generici
```java
Function<String, Integer> toInteer = Integer::valueOf;
Integer k = toInteger.apply("123");
```
metodi: 
- andThen()
- apply()
- compose()
- identity()
### supplier
funzione senza argomenti in input
```java
Supplier<Person> personSupplier = Person::newPersonSupplier.get(); // new Person()
```

### consumer
funzione con un argomento di tipo generico T e nessun tipo di ritorno
//slide 57, 58

## for each su java.util.Collection
le collection sono ora dotate di un metodo forEach che prende in input un’interfaccia Consumer  // slide 59

## coda 
- fifo
- esiste intefaccia Queue(LinkedList implementa l’intefaccia Queue)
# stack
- lifo
- esiste un’implementazione standard mediante la classe Stack (implementa l’intefaccia List)

## come scegliere un contenitorie
come voglio accedere agli elementi ?
quali sono i tipi degli elementi o tipi di chiavi e valori ?
l’ordine degli elementi o delle chiavi è importante ?
per una collezione non mappa, quali operazioni devono essere veloci ?
se usate rappresentazioni ad albero(TreeSet e TreeMap), serve che si implementi Comparable ?

//alberi

# eccezioni
- le eccezioni rappresentano un meccanismo utile a notificare e gestire gli errori
- un’eccezione indica che durante l’esecuzione si è verificato un errore 
- un eccezione indica un comportamento anomalo, che si discosta dalla normale esecuzione
- la gestione delle eccezioni porta a codice più robusto e sicuro

eccezioni notevoli:

| eccezione                 | descrizione |
| ------------------------- | ----------- |
| IndexOutOfBoundsException |             |
| ClassCastException        |             |
| ArithmeticException       |             |
| lupo gay                  |             |
| ParseException            |             |
| IOError e IOException     |             |
| IllegalArgumentException  |             |
| NumberFormatException     |             |

```java
try{
	svolgi compito 1
	svolgi compito 2
	svolgi compito 3
	svolgi compito 4
}
catch(ExceptionType1 e1){}
catch(ExceptionType2 e2){}
catch(ExceptionType3 e3){}
catch(ExceptionType4 e4){}
finally{}

```

l’ordine dei catch conta !!

//slide 19: dato che NumberFormatException è sottotipo di IllegalArgumentException e posizionata in ordine dopo IllegalArgumentException, non verrà mai catchata.

